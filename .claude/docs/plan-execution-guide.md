# Plan Execution Guide

This guide explains how the main agent should execute plans generated by the Planning Agent.

## Overview

The Planning Agent outputs a JSON plan with phases containing tasks. Each phase can be either:
- **Parallel**: All tasks run simultaneously
- **Sequential**: Tasks run one after another

## Execution Algorithm

```
1. Parse the JSON plan
2. Initialize results = {}

3. For each phase in order:

   a. Resolve variable substitutions:
      - Replace {{task_id}} with results[task_id]

   b. If phase.parallel == true:
      - Launch ALL tasks using Task tool in a SINGLE message
      - Wait for all tasks to complete
      - Store outputs: results[task.id] = task_output

   c. If phase.parallel == false:
      - Execute tasks one by one
      - Store each output before proceeding

4. Execute verification steps
5. Report success/failure based on criteria
```

## Variable Substitution

Before executing a task, replace all `{{task_id}}` placeholders with actual outputs:

```
Original prompt:
"Using results from {{research_auth}}, implement..."

After substitution:
"Using results from [ACTUAL OUTPUT FROM research_auth TASK], implement..."
```

## Task Tool Mapping

| Plan Agent Type | Task Tool subagent_type |
|-----------------|-------------------------|
| `research` | `research` |
| `deep-research` | `deep-research` |
| `explore` | `Explore` |
| `implement` | `general-purpose` |
| `review` | `general-purpose` |

## Parallel Execution Example

When `phase.parallel == true`, you MUST send ALL tasks in a SINGLE message with multiple Task tool calls:

```xml
<!-- CORRECT: Single message with multiple Task calls -->
<function_calls>
  <invoke name="Task">
    <parameter name="subagent_type">research</parameter>
    <parameter name="description">Research auth patterns</parameter>
    <parameter name="prompt">Research JWT vs session auth...</parameter>
  </invoke>
  <invoke name="Task">
    <parameter name="subagent_type">Explore</parameter>
    <parameter name="description">Explore existing code</parameter>
    <parameter name="prompt">Find auth-related files...</parameter>
  </invoke>
</function_calls>
```

**WRONG** - Separate messages (runs sequentially):
```xml
<!-- Message 1 -->
<function_calls>
  <invoke name="Task">...</invoke>
</function_calls>

<!-- Message 2 (after waiting) -->
<function_calls>
  <invoke name="Task">...</invoke>
</function_calls>
```

## Sequential Execution

When `phase.parallel == false`, execute tasks one at a time and wait for each result before proceeding to the next.

## Result Collection

After each task completes, store its output in a results dictionary:

```
results = {
  "research_auth": "JWT is recommended because...",
  "explore_code": "Found files: auth.js, middleware/auth.js...",
  ...
}
```

Use these results for variable substitution in subsequent phases.

## Error Handling

1. **Task Failure**: If a task fails, log the error and continue with other tasks if possible
2. **Critical Failure**: If a task marked as critical fails, abort the plan
3. **Retry Logic**: Retry failed tasks up to 2 times before marking as failed

## Verification

After all phases complete:

1. Execute each step in `verification.steps`
2. Check each criterion in `verification.success_criteria`
3. Report overall success/failure

## Example Execution Flow

Given this plan:
```json
{
  "phases": [
    {"phase": 1, "parallel": true, "tasks": [A, B, C]},
    {"phase": 2, "parallel": false, "depends_on": [1], "tasks": [D]},
    {"phase": 3, "parallel": true, "depends_on": [2], "tasks": [E, F]}
  ]
}
```

Execution order:
```
Time 0: Start A, B, C (parallel)
Time 1: Wait for A, B, C to complete
Time 2: Start D (uses results from A, B, C)
Time 3: Wait for D to complete
Time 4: Start E, F (parallel, uses results from D)
Time 5: Wait for E, F to complete
Time 6: Run verification
```
